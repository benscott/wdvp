<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">

    <script src="https://d3js.org/d3.v4.js"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>
    <script src="http://d3js.org/queue.v1.min.js"></script>
    <script src="d3-scale-radial.js"></script>

    <link rel="stylesheet" href="css/styles.css">

</head>

<body>

    <div class="wrapper">
        <div class="col-1">
            <svg width="700" height="700" id="chart"></svg>
        </div>
        <div class="col-2">
            <div>
                <h1>World Happiness</h1>
                <h2>What makes a country happy?</h2>
                <div width="200" height="700" id="info-box"></div>
            </div>
        </div>
    </div>

    <!-- <svg width="960" height="960" font-family="sans-serif" font-size="10"></svg> -->

    <!-- <script src="./visualisation.js"></script> -->



    <script>
        var dataset;

        var svg = d3.select("svg#chart"),
            width = +svg.attr("width"),
            height = +svg.attr("height");

        var svgInfoBox = d3.select("svg#info-box"),
            width = +svg.attr("width"),
            height = +svg.attr("height");

        var width = 700,
            height = 700,
            dragSensitivity = 0.30, // Amount globe moves on drag. Posibly tweak based on size?
            innerRadius = 120, // FIXME: For globe
            outerRadius = Math.min(width, height) * 0.35,
            mapScale = innerRadius - 2;

        // var svg = d3.select("body").append("svg")
        //     .attr("width", width)
        //     .attr("height", height)

        var countryTooltip = d3.select("body").append("div")
            .attr("id", "countryTooltip")
            .attr("class", "hidden");

        var color = d3.scaleQuantize()
            .range(["rgb(237,248,233)", "rgb(186,228,179)",
                "rgb(116,196,118)", "rgb(49,163,84)", "rgb(0,109,44)"]);

        var projection = d3.geoOrthographic()
            .scale(mapScale)
            .rotate([0, 0])
            .translate([width / 2, height / 2])
            .clipAngle(90);

        var path = d3.geoPath().projection(projection);

        var dragging = function (d) {
            var rotate = projection.rotate();
            projection.rotate([d3.event.x * dragSensitivity, -d3.event.y * dragSensitivity, rotate[2]]);
            svg.selectAll("path.map").attr("d", path);
        }

        var subject = function (d) {
            var rotate = projection.rotate();
            return { x: rotate[0] / dragSensitivity, y: -rotate[1] / dragSensitivity };
        }

        var drag = d3.drag()
            .subject(subject)
            .on("start", function () {
                d3.event.sourceEvent.stopPropagation(); // silence other listeners
                if (d3.event.sourceEvent.which == 1)
                    dragInitiated = true;
            })
            .on("drag", dragging);

        queue()
            .defer(d3.json, "./data/world-110m.json")
            .defer(d3.tsv, "./data/world-110m-country-names.tsv")
            .defer(d3.csv, "./data/whr-data.csv")
            .await(ready);

        function ready(error, worldTopologyData, countryNamesData, worldHappinessData) {

            // Just throw an error if there's a problem
            if (error) throw error;

            dataset = topojson.feature(worldTopologyData, worldTopologyData.objects.countries).features;

            // Amalgamate all the data into one dataset
            countryNamesByID = {}
            countryNamesData.forEach(function (d) {
                countryNamesByID[d.id] = d.name;
            });

            worldHappinessByName = {}
            worldHappinessData.forEach(function (d) {
                worldHappinessByName[d['Country']] = d
            });

            // FIXME: Remove vars
            var countryName, countryHappiness, happinessBreakdown
            dataset.forEach(function (d, i) {
                countryName = countryNamesByID[d.id];
                countryHappiness = worldHappinessByName[countryName];
                dataset[i]['properties']['name'] = countryName;
                dataset[i]['properties']['happiness'] = countryHappiness;
            });

            // FIXME: Yuk!!
            var data = []
            var z

            radialStackedBar()
            choroplethGlobe()
            onSelectCountry()

            function radialStackedBar() {

                g = svg.append("g").attr("transform", "translate(" + width / 2 + "," + height * 0.5 + ")");

                var x = d3.scaleBand()
                    .range([0, 2 * Math.PI])
                    .align(0);

                var y = d3.scaleRadial()
                    .range([innerRadius, outerRadius]);

                z = d3.scaleOrdinal()
                    .range(["#9D7800", "#955C00", "#8A3C09", "#7A0022", '#800023', "#390E2D"]);

                var columns = Object.keys(dataset[0]['properties']['happiness']);
                var reservedColumns = [
                    'Country',
                    'Happiness score'
                ]

                data.columns = columns.filter(function (value) {
                    return -1 === reservedColumns.indexOf(value)
                });

                dataset.forEach(function (d) {
                    var countryHappiness;
                    if (typeof (d.properties['happiness']) !== 'undefined') {
                        countryHappiness = d.properties['happiness'];
                        for (i = 0, total = 0; i < data.columns.length; ++i) {
                            var column = data.columns[i];
                            total += parseFloat(countryHappiness[column]);
                        }
                        // The explained total doesn't always match the happiness score
                        // So bump it up a bit so it does
                        if (total != countryHappiness['Happiness score']) {
                            var diffFactor = countryHappiness['Happiness score'] / total
                            for (i = 0, total = 0; i < data.columns.length; ++i) {
                                var column = data.columns[i];
                                countryHappiness[column] *= diffFactor
                            }
                        }

                        countryHappiness['total'] = countryHappiness['Happiness score'];
                        countryHappiness['name'] = d.properties['name'];
                        countryHappiness['id'] = d.id;
                        countryHappiness['centroid'] = d3.geoCentroid(d);


                        data.push(countryHappiness)
                    }
                });

                data.sort(function (a, b) { return b.total - a.total; });

                x.domain(data.map(function (d) { return d['name']; }));

                y.domain([0, d3.max(data, function (d) { return d.total; })]);

                z.domain(data.columns);

                var stack = d3.stack()
                    .keys(data.columns)

                g.append("g")
                    .selectAll("g")
                    .data(stack(data))
                    .enter().append("g")
                    .attr("fill", function (d) {
                        return z(d.key);
                    })
                    .selectAll("path")
                    .data(function (d) { return d; })
                    .enter().append("path")
                    .attr("class", function (d) {
                        return 'country-' + d.data.id
                    })
                    .on("mouseover", function (d) {
                        rotateMapToCentroid(d.data.centroid)
                        onHoverCountry(d.data)
                    })
                    .on("mouseout", function (d) {
                        onHoverOutCountry(d.data)
                    })
                    .attr("d", d3.arc()
                        .innerRadius(function (d) {
                            return y(d[0]);
                        })
                        .outerRadius(function (d) {
                            return y(d[1]);
                        })
                        .startAngle(function (d) {
                            return x(d.data['name']);
                        })
                        .endAngle(function (d) {
                            return x(d.data['name']) + x.bandwidth();
                        })
                        .padAngle(0.01)
                        .padRadius(innerRadius)
                    );

                outerRadius += 10

                var label = g.append("g")
                    .selectAll("g")
                    .data(data)
                    .enter().append("g")
                    .attr("text-anchor", "start")
                    .attr("class", function (d) {
                        return 'label country-' + d.id
                    })
                    .attr("transform", function (d) {
                        return "rotate(" + ((x(d.name) + x.bandwidth() / 2) * 180 / Math.PI - 90) + ")translate(" + outerRadius + ",0)";
                    })
                    .on("mouseover", function (d) {
                        rotateMapToCentroid(d.centroid)
                        onHoverCountry(d)
                    })
                    .on("mouseout", function (d) {
                        onHoverOutCountry(d)
                    })

                label.append("text")
                    .attr("transform", function (d) {
                        return (x(d.name) + x.bandwidth() / 2 + Math.PI / 2) % (2 * Math.PI) < Math.PI ? "rotate(0)translate(0,5)" : "rotate(0)translate(0,5)";
                    })
                    .text(function (d) { return d.name; })

            }

            // FIXME - This should be an object, with all the stuff before
            // Files in an init() function, and then a build method
            function choroplethGlobe() {

                //Create a container in which all pan-able elements will live
                var map = svg.append("g")
                    .call(drag);  //Bind the dragging behavior

                //Create a new, invisible background rect to catch drag events
                map.append("circle")
                    .attr("cx", width / 2)
                    .attr("cy", height / 2)
                    .attr("r", mapScale)
                    .attr("class", "map-background")

                color.domain([
                    d3.min(dataset, function (d) {
                        if (typeof (d.properties.happiness) != 'undefined') {
                            return d.properties.happiness['Happiness score'];
                        }

                    }),
                    d3.max(dataset, function (d) {
                        if (typeof (d.properties.happiness) != 'undefined') {
                            return d.properties.happiness['Happiness score'];
                        }
                    })
                ]);

                var world = map.selectAll("path")
                    .data(dataset)
                    .enter()
                    .append("path")
                    .attr("d", path)
                    .attr("class", function (d) {
                        return 'map country-' + d.id
                    })
                    // Choropleth
                    .style("fill", function (d) {
                        if (typeof (d.properties.happiness) == 'undefined') {
                            return '#08101D'
                        }
                        var value = d.properties.happiness['Happiness score'];
                        return '#08101D'
                        // return color(value);
                    })
                    // Event handlers
                    .on("mouseover", function (d) {
                        if (d.properties.name) {
                            onHoverCountry(d)
                        }

                    })
                    .on("mouseout", function (d) {
                        onHoverOutCountry(d)

                    })
                    .on("click", function (d) {
                        onSelectCountry(d);
                    })
            }

            // var updateCountryTooltipPosition = function () {
            //     var xPosition = d3.event.pageX + 7;
            //     var yPosition = d3.event.pageY - 15;
            //     countryTooltip.style("left", xPosition + "px")
            //         .style("top", yPosition + "px")
            // }

            var onHoverCountry = function (d) {
                d3.selectAll('.hovered').classed("hovered", false);
                d3.selectAll('.country-' + d.id).classed("hovered", true);
            }

            var onHoverOutCountry = function (d) {
                d3.selectAll('.hovered').classed("hovered", false);
            }

            var rotateMapToCentroid = function (centroid) {
                (function transition() {
                    d3.transition()
                        .duration(1500)
                        .tween("rotate", function () {
                            var r = d3.interpolate(projection.rotate(), [-centroid[0], -centroid[1]]);
                            return function (t) {
                                projection.rotate(r(t));
                                svg.selectAll("path.map").attr("d", path)
                            };
                        })
                })();
            }

            function onSelectCountry(d) {

                var d2 = [4, 8, 15, 16, 23, 42];

                // // var x = d3.scale.linear()
                // //     .domain([0, d3.max(data)])
                // //     .range([0, 200]);

                // // for (i = 0; i < data.columns.length; ++i) {
                // //     var column = data.columns[i]
                // //     var colour = z(column)
                // // }

                var scale = d3.scaleLinear();

                d3.select("#info-box")
                    .selectAll("div")
                    .data(d2)
                    .enter()
                    .append("div")
                    .attr("class", "bar");



                // var data = [4, 8, 15, 16, 23, 42];


            }

        }



    </script>



</body>




</html>